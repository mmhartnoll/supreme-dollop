using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using MindSculptor.DataAccess.Modelled.Records;
using MindSculptor.DataAccess.Modelled.Records.Fields;
using MindSculptor.Tools.Applications.DataContextGenerator.Extensions;
using MindSculptor.Tools.CodeGeneration.Declarations;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;

namespace MindSculptor.Tools.Applications.DataContextGenerator.FileGenerators.TableFiles.Methods
{
    internal class NewRecordAsyncPublicMethodDeclaration : MethodDeclaration
    {
        private readonly RecordDefinition recordDefinition;

        private NewRecordAsyncPublicMethodDeclaration(RecordDefinition recordDefinition)
            : base($"Task<{recordDefinition.RecordName}>", "NewRecordAsync", MemberAccessModifiers.Public, MemberModifiers.Async)
        {
            this.recordDefinition = recordDefinition;

            foreach (var fieldDefinition in recordDefinition.Fields)
            {
                if (!(fieldDefinition is IdField idField) || !idField.IsAutoGenerated)
                {
                    var parameterName = fieldDefinition.Name.FormatAsVariableName();
                    AddParameter(TypeDeclaration.Create(fieldDefinition.MappedDalType, fieldDefinition.IsNullable), parameterName);
                }
            }

            AddParameter(typeof(CancellationToken), nameof(CancellationToken).FormatAsVariableName(), SyntaxFactory.ParseExpression("default"));
        }

        public static NewRecordAsyncPublicMethodDeclaration Create(RecordDefinition recordDefinition)
            => new NewRecordAsyncPublicMethodDeclaration(recordDefinition);

        protected override IEnumerable<StatementSyntax> GetMethodStatementSyntaxes()
        {
            var argumentList = new List<ArgumentSyntax>();
            argumentList.Add(SyntaxFactory.Argument(SyntaxFactory.IdentifierName("command")));
            foreach (var fieldDefinition in recordDefinition.Fields)
            {
                if (fieldDefinition is IdField idField && idField.IsAutoGenerated)
                {
                    var guidInvocationExpression = SyntaxFactory.InvocationExpression(SyntaxFactory.IdentifierName("Guid.NewGuid"));
                    argumentList.Add(SyntaxFactory.Argument(guidInvocationExpression));
                }
                else 
                {
                    var argumentName = fieldDefinition.Name.FormatAsVariableName();
                    argumentList.Add(SyntaxFactory.Argument(SyntaxFactory.IdentifierName(argumentName)));
                }
            }
            argumentList.Add(SyntaxFactory.Argument(SyntaxFactory.IdentifierName(nameof(CancellationToken).FormatAsVariableName())));

            var newRecordInvocationExpression = SyntaxFactory.InvocationExpression(SyntaxFactory.IdentifierName("NewRecordAsync"))
                .AddArgumentListArguments(argumentList.ToArray());

            var lambdaExpression = SyntaxFactory.ParenthesizedLambdaExpression()
                .WithBody(newRecordInvocationExpression)
                .AddParameterListParameters(
                    SyntaxFactory.Parameter(SyntaxFactory.Identifier("command")),
                    SyntaxFactory.Parameter(SyntaxFactory.Identifier("cancellationToken")));

            var executeInvocationExpression = SyntaxFactory.InvocationExpression(SyntaxFactory.IdentifierName("DatabaseContext.ExecuteAsync"))
                .AddArgumentListArguments(
                    SyntaxFactory.Argument(lambdaExpression),
                    SyntaxFactory.Argument(SyntaxFactory.IdentifierName(nameof(CancellationToken).FormatAsVariableName())));

            var configureAwaitInvocationExpression = SyntaxFactory.InvocationExpression(
                    SyntaxFactory.MemberAccessExpression(
                        SyntaxKind.SimpleMemberAccessExpression,
                        executeInvocationExpression,
                        SyntaxFactory.IdentifierName("ConfigureAwait")))
                .AddArgumentListArguments(SyntaxFactory.Argument(SyntaxFactory.ParseExpression("false")));

            var awaitExpression = SyntaxFactory.AwaitExpression(configureAwaitInvocationExpression);

            yield return SyntaxFactory.ReturnStatement(awaitExpression);
        }
    }
}
