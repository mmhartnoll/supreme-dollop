using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using MindSculptor.DataAccess.Modelled.Records;
using MindSculptor.DataAccess.Modelled.Records.Fields;
using MindSculptor.Tools.Applications.DataContextGenerator.Extensions;
using MindSculptor.Tools.CodeGeneration.Declarations;
using System;
using System.Collections.Generic;
using System.Linq;

namespace MindSculptor.Tools.Applications.DataContextGenerator.FileGenerators.TableFiles.Methods
{
    internal class NewRecordForeignKeyPublicMethodDeclaration : MethodDeclaration
    {
        private readonly Dictionary<string, string> parameterLookup = new Dictionary<string, string>();
        private readonly RecordDefinition recordDefinition;

        private NewRecordForeignKeyPublicMethodDeclaration(RecordDefinition recordDefinition) 
            : base(recordDefinition.RecordName, "NewRecord", MemberAccessModifiers.Public)
        {
            this.recordDefinition = recordDefinition;

            foreach (var foreignKey in recordDefinition.ForeignKeys)
            {
                var referencedRecord = foreignKey.ReferencedKey.RecordDefinition;
                var parameterName = referencedRecord.RecordName.FormatAsVariableName();

                var fieldPairs = foreignKey.Fields.Zip(foreignKey.ReferencedKey.Fields);
                var existingForeignKeyParameters = new HashSet<string>();

                foreach (var fieldPair in fieldPairs)
                    if (!parameterLookup.ContainsKey(fieldPair.First.Field.Name))
                    {
                        parameterLookup.Add(fieldPair.First.Field.Name, $"{parameterName}.{fieldPair.Second.Field.Name}");
                        if (!existingForeignKeyParameters.Contains(parameterName))
                        {
                            AddParameter(referencedRecord.RecordName, parameterName);
                            existingForeignKeyParameters.Add(parameterName);
                        }
                    }
            }

            foreach (var fieldDefinition in recordDefinition.Fields)
            {
                if (!parameterLookup.ContainsKey(fieldDefinition.Name) && (!(fieldDefinition is IdField idField) || !idField.IsAutoGenerated))
                {
                    var parameterName = fieldDefinition.Name.FormatAsVariableName();
                    AddParameter(TypeDeclaration.Create(fieldDefinition.MappedDalType, fieldDefinition.IsNullable), parameterName);
                    parameterLookup.Add(fieldDefinition.Name, parameterName);
                }
            }
        }

        public static NewRecordForeignKeyPublicMethodDeclaration Create(RecordDefinition recordDefinition)
            => new NewRecordForeignKeyPublicMethodDeclaration(recordDefinition);

        protected override IEnumerable<StatementSyntax> GetMethodStatementSyntaxes()
        {
            var argumentList = new List<ArgumentSyntax>();
            argumentList.Add(SyntaxFactory.Argument(SyntaxFactory.IdentifierName("command")));
            foreach (var fieldDefinition in recordDefinition.Fields)
            {
                if (fieldDefinition is IdField idField && idField.IsAutoGenerated)
                {
                    var guidInvocationExpression = SyntaxFactory.InvocationExpression(SyntaxFactory.IdentifierName("Guid.NewGuid"));
                    argumentList.Add(SyntaxFactory.Argument(guidInvocationExpression));
                }
                else if (parameterLookup.TryGetValue(fieldDefinition.Name, out var parameter))
                    argumentList.Add(SyntaxFactory.Argument(SyntaxFactory.IdentifierName(parameter)));
                else
                    throw new Exception($"Failed to determine a valid argument for field '{fieldDefinition.Name}' on record '{recordDefinition.TableName}'.");
            }

            var newRecordInvocationExpression = SyntaxFactory.InvocationExpression(SyntaxFactory.IdentifierName("NewRecord"))
                .AddArgumentListArguments(argumentList.ToArray());

            var lambdaExpression = SyntaxFactory.SimpleLambdaExpression(
                SyntaxFactory.Parameter(SyntaxFactory.Identifier("command")), 
                newRecordInvocationExpression);

            var executeInvocationExpression = SyntaxFactory.InvocationExpression(SyntaxFactory.IdentifierName("DatabaseContext.Execute"))
                .AddArgumentListArguments(SyntaxFactory.Argument(lambdaExpression));

            yield return SyntaxFactory.ReturnStatement(executeInvocationExpression);
        }
    }
}
