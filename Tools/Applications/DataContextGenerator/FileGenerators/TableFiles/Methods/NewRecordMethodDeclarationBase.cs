using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using MindSculptor.DataAccess.Modelled.Records;
using MindSculptor.DataAccess.Modelled.Records.Fields;
using MindSculptor.Tools.Applications.DataContextGenerator.Extensions;
using MindSculptor.Tools.CodeGeneration.Declarations;
using System;
using System.Collections.Generic;
using System.Linq;

namespace MindSculptor.Tools.Applications.DataContextGenerator.FileGenerators.TableFiles.Methods
{
    internal abstract class NewRecordMethodDeclarationBase : MethodDeclaration
    {
        private readonly Dictionary<string, string> parameterLookup = new Dictionary<string, string>();
        private readonly RecordDefinition recordDefinition;

        protected NewRecordMethodDeclarationBase(TypeDeclaration type, string name, MemberModifiers modifiers, RecordDefinition recordDefinition)
                : base(type, name, MemberAccessModifiers.Public, modifiers)
        {
            this.recordDefinition = recordDefinition;

            foreach (var foreignKey in recordDefinition.ForeignKeys)
            {
                var referencedRecord = foreignKey.ReferencedKey.RecordDefinition;
                var parameterName = referencedRecord.RecordName.FormatAsVariableName();

                var fieldPairs = foreignKey.Fields.Zip(foreignKey.ReferencedKey.Fields);
                var existingForeignKeyParameters = new HashSet<string>();

                foreach (var fieldPair in fieldPairs)
                    if (!parameterLookup.ContainsKey(fieldPair.First.Field.Name))
                    {
                        parameterLookup.Add(fieldPair.First.Field.Name, $"{parameterName}.{fieldPair.Second.Field.Name}");
                        if (!existingForeignKeyParameters.Contains(parameterName))
                        {
                            AddParameter(referencedRecord.RecordName, parameterName);
                            existingForeignKeyParameters.Add(parameterName);
                        }
                    }
            }

            foreach (var fieldDefinition in recordDefinition.Fields)
            {
                if (!parameterLookup.ContainsKey(fieldDefinition.Name) && (!(fieldDefinition is IdField idField) || !idField.IsAutoGenerated))
                {
                    var parameterName = fieldDefinition.Name.FormatAsVariableName();
                    AddParameter(TypeDeclaration.Create(fieldDefinition.MappedDalType, fieldDefinition.IsNullable), parameterName);
                    parameterLookup.Add(fieldDefinition.Name, parameterName);
                }
            }
        }

        protected override IEnumerable<StatementSyntax> GetMethodStatementSyntaxes()
        {
            var argumentList = new List<ArgumentSyntax>();
            argumentList.Add(SyntaxFactory.Argument(SyntaxFactory.IdentifierName("DataContext")));
            foreach (var fieldDefinition in recordDefinition.Fields)
            {
                if (fieldDefinition is IdField idField && idField.IsAutoGenerated)
                {
                    var guidInvocationExpression = SyntaxFactory.InvocationExpression(SyntaxFactory.IdentifierName("Guid.NewGuid"));
                    argumentList.Add(SyntaxFactory.Argument(guidInvocationExpression));
                }
                else if (parameterLookup.TryGetValue(fieldDefinition.Name, out var parameter))
                    argumentList.Add(SyntaxFactory.Argument(SyntaxFactory.IdentifierName(parameter)));
                else
                    throw new Exception($"Failed to determine a valid argument for field '{fieldDefinition.Name}' on record '{recordDefinition.TableName}'.");
            }
            var createInvocationExpression = SyntaxFactory.InvocationExpression(SyntaxFactory.IdentifierName($"{recordDefinition.RecordName}.Create"))
                .AddArgumentListArguments(argumentList.ToArray());
            var variableDeclarationSyntax = SyntaxFactory.VariableDeclaration(TypeDeclaration.Var)
                .AddVariables(SyntaxFactory.VariableDeclarator(
                    SyntaxFactory.Identifier("newRecord"),
                    null,
                    SyntaxFactory.EqualsValueClause(createInvocationExpression)));
            yield return SyntaxFactory.LocalDeclarationStatement(variableDeclarationSyntax);

            var equalsValueClause = SyntaxFactory.EqualsValueClause(SyntaxFactory.InvocationExpression(
                SyntaxFactory.IdentifierName("DataContext.Connection.CreateCommand")));
            var variableDeclaration = SyntaxFactory.VariableDeclaration(TypeDeclaration.Var)
                .AddVariables(SyntaxFactory.VariableDeclarator(
                    SyntaxFactory.Identifier("command"),
                    null,
                    equalsValueClause));
            yield return SyntaxFactory.UsingStatement(SyntaxFactory.Block(GetUsingBlockStatements()))
                .WithDeclaration(variableDeclaration);

            yield return SyntaxFactory.ReturnStatement(SyntaxFactory.IdentifierName("newRecord"));

            IEnumerable<StatementSyntax> GetUsingBlockStatements()
            {
                var assignmentExpression = SyntaxFactory.AssignmentExpression(
                    SyntaxKind.SimpleAssignmentExpression,
                    SyntaxFactory.IdentifierName("command.Transaction"),
                    SyntaxFactory.ParseExpression("DataContext.Transaction"));
                yield return SyntaxFactory.IfStatement(
                    SyntaxFactory.IdentifierName("DataContext.HasTransaction"),
                    SyntaxFactory.ExpressionStatement(assignmentExpression));

                yield return SyntaxFactory.ExpressionStatement(SyntaxFactory.AssignmentExpression(
                    SyntaxKind.SimpleAssignmentExpression,
                    SyntaxFactory.IdentifierName("command.CommandText"),
                    SyntaxFactory.ParseExpression($@"""{GetCommandText()}""")));

                foreach (var fieldDefinition in recordDefinition.Fields)
                    yield return SyntaxFactory.ExpressionStatement(SyntaxFactory.InvocationExpression(
                            SyntaxFactory.IdentifierName("command.AddParameter"))
                        .AddArgumentListArguments(
                            SyntaxFactory.Argument(SyntaxFactory.ParseExpression($@"""{fieldDefinition.Name}""")),
                            SyntaxFactory.Argument(SyntaxFactory.IdentifierName($"newRecord.{fieldDefinition.Name}"))));

                yield return GetExecuteStatementSyntax();

                string GetCommandText()
                {
                    return string.Format("INSERT INTO [{0}].[{1}] ( {2} ) VALUES ( {3} );",
                        recordDefinition.Schema.Name,
                        recordDefinition.TableName,
                        string.Join(", ", recordDefinition.Fields.Select(fieldDefinition => fieldDefinition.Name)),
                        string.Join(", ", recordDefinition.Fields.Select(fieldDefinition => $"@{fieldDefinition.Name}")));
                }
            }
        }

        protected abstract StatementSyntax GetExecuteStatementSyntax();
    }
}
