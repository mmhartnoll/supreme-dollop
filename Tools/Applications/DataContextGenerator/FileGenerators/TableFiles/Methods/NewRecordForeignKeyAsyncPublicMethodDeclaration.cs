using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using MindSculptor.DataAccess.Modelled.Records;
using MindSculptor.DataAccess.Modelled.Records.Fields;
using MindSculptor.Tools.Applications.DataContextGenerator.Extensions;
using MindSculptor.Tools.CodeGeneration.Declarations;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;

namespace MindSculptor.Tools.Applications.DataContextGenerator.FileGenerators.TableFiles.Methods
{
    internal class NewRecordForeignKeyAsyncPublicMethodDeclaration : MethodDeclaration
    {
        private readonly Dictionary<string, string> parameterLookup = new Dictionary<string, string>();
        private readonly RecordDefinition recordDefinition;

        private NewRecordForeignKeyAsyncPublicMethodDeclaration(RecordDefinition recordDefinition)
            : base($"Task<{recordDefinition.RecordName}>", "NewRecordAsync", MemberAccessModifiers.Public, MemberModifiers.Async)
        {
            this.recordDefinition = recordDefinition;

            foreach (var foreignKey in recordDefinition.ForeignKeys)
            {
                var referencedRecord = foreignKey.ReferencedKey.RecordDefinition;
                var parameterName = referencedRecord.RecordName.FormatAsVariableName();

                var fieldPairs = foreignKey.Fields.Zip(foreignKey.ReferencedKey.Fields);
                var existingForeignKeyParameters = new HashSet<string>();

                foreach (var fieldPair in fieldPairs)
                    if (!parameterLookup.ContainsKey(fieldPair.First.Field.Name))
                    {
                        parameterLookup.Add(fieldPair.First.Field.Name, $"{parameterName}.{fieldPair.Second.Field.Name}");
                        if (!existingForeignKeyParameters.Contains(parameterName))
                        {
                            AddParameter(referencedRecord.RecordName, parameterName);
                            existingForeignKeyParameters.Add(parameterName);
                        }
                    }
            }

            foreach (var fieldDefinition in recordDefinition.Fields)
            {
                if (!parameterLookup.ContainsKey(fieldDefinition.Name) && (!(fieldDefinition is IdField idField) || !idField.IsAutoGenerated))
                {
                    var parameterName = fieldDefinition.Name.FormatAsVariableName();
                    AddParameter(TypeDeclaration.Create(fieldDefinition.MappedDalType, fieldDefinition.IsNullable), parameterName);
                    parameterLookup.Add(fieldDefinition.Name, parameterName);
                }
            }

            AddParameter(typeof(CancellationToken), nameof(CancellationToken).FormatAsVariableName(), SyntaxFactory.ParseExpression("default"));
        }

        public static NewRecordForeignKeyAsyncPublicMethodDeclaration Create(RecordDefinition recordDefinition)
            => new NewRecordForeignKeyAsyncPublicMethodDeclaration(recordDefinition);

        protected override IEnumerable<StatementSyntax> GetMethodStatementSyntaxes()
        {
            var argumentList = new List<ArgumentSyntax>();
            argumentList.Add(SyntaxFactory.Argument(SyntaxFactory.IdentifierName("command")));
            foreach (var fieldDefinition in recordDefinition.Fields)
            {
                if (fieldDefinition is IdField idField && idField.IsAutoGenerated)
                {
                    var guidInvocationExpression = SyntaxFactory.InvocationExpression(SyntaxFactory.IdentifierName("Guid.NewGuid"));
                    argumentList.Add(SyntaxFactory.Argument(guidInvocationExpression));
                }
                else if (parameterLookup.TryGetValue(fieldDefinition.Name, out var parameter))
                    argumentList.Add(SyntaxFactory.Argument(SyntaxFactory.IdentifierName(parameter)));
                else
                    throw new Exception($"Failed to determine a valid argument for field '{fieldDefinition.Name}' on record '{recordDefinition.TableName}'.");
            }
            argumentList.Add(SyntaxFactory.Argument(SyntaxFactory.IdentifierName(nameof(CancellationToken).FormatAsVariableName())));

            var newRecordInvocationExpression = SyntaxFactory.InvocationExpression(SyntaxFactory.IdentifierName("NewRecordAsync"))
                .AddArgumentListArguments(argumentList.ToArray());

            var lambdaExpression = SyntaxFactory.ParenthesizedLambdaExpression()
                .WithBody(newRecordInvocationExpression)
                .AddParameterListParameters(
                    SyntaxFactory.Parameter(SyntaxFactory.Identifier("command")),
                    SyntaxFactory.Parameter(SyntaxFactory.Identifier("cancellationToken")));

            var executeInvocationExpression = SyntaxFactory.InvocationExpression(SyntaxFactory.IdentifierName("DataContext.ExecuteAsync"))
                .AddArgumentListArguments(
                    SyntaxFactory.Argument(lambdaExpression),
                    SyntaxFactory.Argument(SyntaxFactory.IdentifierName(nameof(CancellationToken).FormatAsVariableName())));

            var configureAwaitInvocationExpression = SyntaxFactory.InvocationExpression(
                    SyntaxFactory.MemberAccessExpression(
                        SyntaxKind.SimpleMemberAccessExpression,
                        executeInvocationExpression,
                        SyntaxFactory.IdentifierName("ConfigureAwait")))
                .AddArgumentListArguments(SyntaxFactory.Argument(SyntaxFactory.ParseExpression("false")));

            var awaitExpression = SyntaxFactory.AwaitExpression(configureAwaitInvocationExpression);

            yield return SyntaxFactory.ReturnStatement(awaitExpression);
        }
    }
}
