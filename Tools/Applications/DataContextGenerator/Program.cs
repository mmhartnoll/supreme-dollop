using MindSculptor.DataAccess.Modelled;
using MindSculptor.Tools.Applications.DataContextGenerator.FileGenerators.DataContextFiles;
using MindSculptor.Tools.Applications.DataContextGenerator.FileGenerators.ExpressionFiles;
using MindSculptor.Tools.Applications.DataContextGenerator.FileGenerators.RecordFiles;
using MindSculptor.Tools.Applications.DataContextGenerator.FileGenerators.SchemaFiles;
using MindSculptor.Tools.Applications.DataContextGenerator.FileGenerators.TableFiles;
using MindSculptor.Tools.CodeGeneration;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;

namespace MindSculptor.Tools.Applications.DataContextGenerator
{
    class Program
    {
        static void Main(string[] args)
        {
            new Program().Run();
        }

        private void Run()
        {
            var rootNamespace = @"MindSculptor.App.AppDataContext";
            var rootFolderPath = @"C:\Users\mmhar\source\repos\supreme-dollop\App\MindSculptor.App.AppDataContext";
            var dataModelPath = @"C:\Users\mmhar\source\repos\supreme-dollop\App\MindSculptor.App.AppDataModel\bin\Debug\netcoreapp3.0\MindSculptor.App.AppDataModel.dll";

            var dataModelAsm = Assembly.LoadFile(dataModelPath);
            var validTypes = dataModelAsm
                .GetTypes()
                .Where(type => type.IsSubclassOf(typeof(DataModel)));
            if (!validTypes.Any())
                throw new Exception($"Assembly '{dataModelAsm.FullName}' does not contain any valid types of type '{nameof(DataModel)}'.");
            if (validTypes.Count() > 1)
                throw new Exception($"Assembly '{dataModelAsm.FullName}' contains more than one type of type '{nameof(DataModel)}'.");

            var dataModel = Activator.CreateInstance(validTypes.First()) as DataModel;
            if (dataModel == null)
                throw new NullReferenceException("Null data model was loaded from Activator.CreateInstance.");

            var generatedFiles = new List<GeneratedCodeFile>();
            generatedFiles.Add(DataContextClassFile.Create(dataModel, rootFolderPath, rootNamespace));

            foreach (var schemaDefinition in dataModel.Schemata)
            {
                generatedFiles.Add(SchemaClassFile.Create(schemaDefinition, rootFolderPath, rootNamespace));

                foreach (var recordDefinition in schemaDefinition.Records)
                {
                    generatedFiles.Add(RecordClassFile.Create(recordDefinition, rootFolderPath, rootNamespace));
                    generatedFiles.Add(ExpressionClassFile.Create(recordDefinition, rootFolderPath, rootNamespace));
                    generatedFiles.Add(TableClassFile.Create(recordDefinition, rootFolderPath, rootNamespace));
                }
            }

            foreach (var file in generatedFiles)
                file.CreateOrUpdateFile();

            var exclusions = generatedFiles.Select(file => file.FilePath);
            CleanUpDirectories(rootFolderPath, "*.AutoGenerated.cs", exclusions);

            Console.WriteLine("\n\nDone!");

            static void CleanUpDirectories(string rootDirectory, string matchingPattern, IEnumerable<string> exclusions)
            {
                foreach (var subDirectory in Directory.GetDirectories(rootDirectory))
                {
                    var obsoleteFiles = Directory
                        .EnumerateFiles(rootDirectory, matchingPattern, SearchOption.AllDirectories)
                        .Where(file => !exclusions.Any(validFile => file == validFile));
                    foreach (var file in obsoleteFiles)
                    {
                        Console.WriteLine($"Deleting obsolete file: {file}");
                        File.Delete(file);
                    }
                    CleanUpDirectories(subDirectory, matchingPattern, exclusions);
                    if (!Directory.GetFiles(subDirectory).Any() && !Directory.GetDirectories(subDirectory).Any())
                    {
                        Console.WriteLine($"Deleting empty directory: {subDirectory}");
                        Directory.Delete(subDirectory, false);
                    }
                }
            }
        }
    }
}
